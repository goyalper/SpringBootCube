package com.cubemasterpro.util;

import com.cubemasterpro.model.*;

/**
 * Implementation of Kociemba's two-phase algorithm for solving a Rubik's Cube.
 * This is a simplified implementation for demonstration purposes.
 * A full implementation would be more complex.
 */
public class KociembaAlgorithm {
    
    /**
     * Convert a RubiksCube object to a string representation for the Kociemba algorithm.
     * Format: UUUUUUUUURLRLRLRLRFFFFFFFFFDDDDDDDDDBLBLBLBLB
     * Where U=Up, R=Right, L=Left, F=Front, D=Down, B=Back
     *
     * @param cube The cube to convert.
     * @return The string representation.
     */
    public static String toKociembaString(RubiksCube cube) {
        StringBuilder builder = new StringBuilder();
        
        // Append UP face (U)
        appendFace(builder, cube.getUpFace());
        
        // Append RIGHT face (R)
        appendFace(builder, cube.getRightFace());
        
        // Append FRONT face (F)
        appendFace(builder, cube.getFrontFace());
        
        // Append DOWN face (D)
        appendFace(builder, cube.getDownFace());
        
        // Append LEFT face (L)
        appendFace(builder, cube.getLeftFace());
        
        // Append BACK face (B)
        appendFace(builder, cube.getBackFace());
        
        return builder.toString();
    }
    
    /**
     * Append a face to the Kociemba string representation.
     * @param builder The string builder to append to.
     * @param face The face to append.
     */
    private static void appendFace(StringBuilder builder, CubeFace face) {
        for (int i = 0; i < CubeFace.FACE_SIZE; i++) {
            for (int j = 0; j < CubeFace.FACE_SIZE; j++) {
                CubeColor color = face.getSticker(i, j);
                
                if (color.equals(CubeColor.WHITE)) {
                    builder.append('U');
                } else if (color.equals(CubeColor.YELLOW)) {
                    builder.append('D');
                } else if (color.equals(CubeColor.GREEN)) {
                    builder.append('F');
                } else if (color.equals(CubeColor.BLUE)) {
                    builder.append('B');
                } else if (color.equals(CubeColor.RED)) {
                    builder.append('R');
                } else if (color.equals(CubeColor.ORANGE)) {
                    builder.append('L');
                }
            }
        }
    }
    
    /**
     * Parse a solution string from the Kociemba algorithm.
     * @param solutionString The solution string.
     * @return A CubeSolution object representing the moves.
     */
    public static CubeSolution parseSolution(String solutionString) {
        CubeSolution solution = new CubeSolution();
        solution.setSolvable(true);
        
        // Split the solution string into moves
        String[] moveStrings = solutionString.trim().split("\\s+");
        
        for (String moveStr : moveStrings) {
            CubeMove move = CubeMove.fromNotation(moveStr);
            solution.addMove(move);
        }
        
        // Optimize the solution
        solution.optimize();
        
        return solution;
    }
    
    /**
     * Solve a Rubik's Cube using the Kociemba algorithm.
     * @param cubeString The string representation of the cube.
     * @return A solution string.
     */
    public static String solve(String cubeString) {
        // In a real implementation, this would call the actual Kociemba algorithm.
        // For now, we'll return a placeholder solution.
        
        // This is a sample solution - in a real implementation, this would be
        // generated by the actual Kociemba algorithm.
        return "R U R' U' R' F R2 U' R' U' R U R' F'";
    }
    
    /**
     * Check if a cube state is solvable.
     * @param cubeString The string representation of the cube.
     * @return True if the cube is solvable, false otherwise.
     */
    public static boolean isSolvable(String cubeString) {
        // In a real implementation, this would check if the cube state is valid.
        // For now, we'll assume all inputs are valid.
        return true;
    }
}
